
End-to-End Encryption Protocol

The authentication system consists of a challenge-response protocol using a private/public key pair generated using the user's password. This allows the client to securely authenticate itself to the server, without directly sending the user's password.

Registration
  - When a user creates an account with a username and password, the client creates a public/private key pair using their password (KDF + salt). The client then sends the public key to the server for storage, along with the username and salt.

Authentication
  - When a user attempts to login, the client recreates the private key using the above method and sends the username to the server along with a challenge request. The server then finds the public key associated with the provided username, and uses it to encrypt some randomly generated bytes which it returns to the client as a response. The client then decrypts these bytes and sends them back to the server. If the decrypted bytes match the original randomly generated bytes, then the client is authenticated, otherwise the client has failed authentication.

The messaging system involves using a symmetric encryption key to encrypt and decrypt all messages at the client level. This key is propogated to all members of a group (chat) by encrypting it with their respective public key. The group member can then decrypt this key with their private key.

Note that this public/private key pair is different than the one used for authentication, which is stored in a database accessible by the server. The messaging key (as it will be referred to) is a separate public key stored in a separate append-only database which is not accessible to the server. Clients can query this database for the messaging key of members that they intend to message, and then use that key to encrypt the symmetric encryption key. This way client don't need to request public keys from the server and risk receiving a MITM's key (in the case of a compromised server).

This database will use a linear hash chain to verify the integrity of all records. On registration, each client will create their messaging key pair and write an entry to the append-only database with the following information:
  - username
  - public_key
  - timestamp
  - entry_hash
  - prev_hash
  - (optional) rotation_signature

The entry hash is the hash of the entire entry including the previous hash, and the previous hash is the hash of the previous entry. This database will prevent modification at the database level, but it also ensures cryptographically ensures the integrity of the data. If a record is modified, then its hash and all subsequent hashes will be invalid. In order to verify a client's public key, another client has to compute the chained hash of every record and compare it to the hash of the final record.

Key Rotation: When creating a new key, a client will append another record to the database with the new public key, but this record will also contain a rotation signature. The signature is a specified set of bytes that is signed with the client's previous private key. This allows other clients to confirm that the new messaging key is created by the same client.

Additional Notes:
  - Clients will locally store messaging keys when they initially fetch them and will compare them to newly fetched keys in all future group creations
  - Group symmetric encryption keys are rotated every 24 hours
  - Authentication and Messaging Keys are rarely rotated (interval TBD)
  - All messages disappear permanently after 24 hours